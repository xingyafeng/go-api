package main

import (
	"fmt"
	"time"
)

/**
	我们发现协程之间的同步非常重要：

		main () 等待了 1 秒让两个协程完成，如果不这样，sendData () 就没有机会输出。
		getData () 使用了无限循环：它随着 sendData () 的发送完成和 ch 变空也结束了。
		如果我们移除一个或所有 go 关键字，程序无法运行，Go 运行时会抛出 panic：

	为什么会这样？运行时会检查所有的协程（也许只有一个是这种情况）是否在等待（可以读取或者写入某个通道），意味着程序无法处理。
	这是死锁（deadlock）形式，运行时可以检测到这种情况。

	注意：不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。
	注意：不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。
	注意：不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。

	默认情况下，通信是同步且无缓冲的：在有接收者接收数据之前，发送不会结束。
	可以想象一个无缓冲的通道在没有空间来保存数据的时候：必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。
	所以通道的发送 / 接收操作在对方准备好之前是阻塞的：

		1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。
			所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。
		2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。

		尽管这看上去是非常严格的约束，实际在大部分情况下工作的很不错。
		程序 channel_block.go 验证了以上理论，一个协程在无限循环中给通道发送整数数据。不过因为没有接收者，只输出了一个数字 0。
**/
func main() {
	ch := make(chan string)

	go sendData(ch)
	go getData(ch)

	time.Sleep(1e9)
}

func sendData(ch chan string) {
	ch <- "Washington"
	ch <- "Tripoli"
	ch <- "London"
	ch <- "Beijing"
	ch <- "Tokio"
}

func getData(ch chan string) {
	var input string
	// time.Sleep(2e9)
	for {
		input = <-ch
		fmt.Printf("%s \n", input)
	}
}
